# Get started with git and github

## Clarifications

`git` is a command-line tool for version-controlled and distributed development.

*github* is a web-based platform for collaborative development with `git`.

=> You can use `git` without *github*, but not *github* without `git`.

There are many similar web services/platforms like *github*, but *github* is
currently the most widely used such platform by far. In other words, this is
where most collaboration happens.


## Introduction to git

### Installation

First, install `git` and perform initial minimal configuration. Use the
instructions provided as part of the *github* documentation for this:

https://docs.github.com/en/get-started/quickstart/set-up-git#setting-up-git

For the moment just follow the three steps - installation, username and email
configuration.

### Using git for local version-control

Let's illustrate basic functionality of `git` with a toy example: a small piece
of code for generating random biological sequences. Get an initial Python
script from [here](./random_seq.py) and store this file in an otherwise empty
folder on your local system.

Open a terminal/console window, `cd` into the folder with the file, and run the
script with:

`python random_seq.py`

Oh, of course! You would need to specify the desired sequence length. Try again
with:

`python random_seq.py 20`

Ah, better! This script promises to be *really* useful, but you will need to
extend its functionality. To keep control over the development process, let's
put this code under version control with `git`.

To do so, while inside the folder with your script, run:

   `git init`
   
   This simple command will turn your folder into a `git` repository, for which
   `git` will, from now on, keep track of changes.
   
   Under the hood, `git` just created a `.git` folder inside your current
   directory. This is where all the bookkeeping of changes will happen.
   
Now run `git status` to see what's up with your brand new repo.
You should see output approximately like this:

```
On branch master

No commits yet

Untracked files:
  (use "git add <file>..." to include in what will be committed)
	random_seq.py

nothing added to commit but untracked files present (use "git add" to track)
```

Hmm, what is that supposed to tell you. First of all, a *commit* in `git` is
like a snapshot of a given repository at a given point in time, which you can
always go back to later. So *commits* are at the very heart of version control,
but the status message says that you don't have any yet. This is because the
`git init` command only sets up the repo, but doesn't yet save a snapshot of it.

The second part of the message tells you that `git` already knows about your
Python script, but doesn't track changes to it yet (that's what *untracked
file* means). At this point any snapshot of the repo would *not* include your
script, but conveniently enough `git` also tells you how to change this.
Follow the instructions and run:

`git add random_seq.py`

and after another `git status` you should see something like:

```
On branch master

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
	new file:   random_seq.py
```

Hmm, still no commits :( At least, the file is now tracked and there's "A
change to be committed".

-----

#### The working directory, commits and the staging area

You can put anything you like into a directory that's under `git` version
control. `git` will ignore everything you didn't explicitly tell it to track
changes for (it will only let you know that there are untracked items in the
status output).

Even changes in *tracked* files will not automatically make it into the next
commit (i.e. the next snapshot of the repository). You need to run `git add
your_file` to add these changes to the changes to be committed. Changes to be
committed are managed by git in what is called a *staging area*. For previously
*untracked* files (like our script) `git add` performs the dual action of
adding the file to the list of tracked files and of adding all of its content
(since its new) to the staging area.

-----

We're very close to creating our first commit now. All that's left to do is to
run:

`git commit`

If you do that, git will drop you into your system's default command-line text
editor and will wait for you to type and save a git commit *message*. Type a
brief one-line message on the first line (like *Add first version of script*),
save and exit from the text editor (saving and exiting will require some key
combinations that are different between different editors). If you typed
something and saved successfully, `git` should now have committed your changes.

-----

#### git commit messages

While working on your commit message you should have seen lots of additional
lines of text that were autogenerated by `git`. All these lines of text where
prefixed with `#` though, which marks them as comment lines that will be
excluded from the final commit message. These comments are `git`'s way to give
you a final overview of the changes it will commit. It can be worthwhile to
take a brief look, at least, at these comments. If you're discovering that you
are about to commit something that doesn't look right, just leave the text
editor without typing any non-comment text. Such an empty commit message will
abort the commit process.

Commit messages are meant to help others and your future self to understand
what changes between this commit and the last one are supposed to do. Writing
good and informative commit messages is an art in itself. A very good
introduction into this topic can be found
[here](https://chris.beams.io/posts/git-commit/).

-----


