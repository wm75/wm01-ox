# Get started with git and github

## Clarifications

`git` is a command-line tool for version-controlled and distributed development.

*github* is a web-based platform for collaborative development with `git`.

=> You can use `git` without *github*, but not *github* without `git`.

There are many similar web services/platforms like *github*, but *github* is
currently the most widely used such platform by far. In other words, this is
where most collaboration happens.


## Introduction to git

### Installation

First, install `git` and perform initial minimal configuration. Use the
instructions provided as part of the *github* documentation for this:

https://docs.github.com/en/get-started/quickstart/set-up-git#setting-up-git

For the moment just follow the three steps - installation, username and email
configuration.

### Using git for local version-control

#### A first git repository

Let's illustrate basic functionality of `git` with a toy example: a small piece
of code for generating random biological sequences. Get an initial Python
script from [here](./random_seq.py) and store this file in an otherwise empty
folder on your local system.

Open a terminal/console window, `cd` into the folder with the file, and run the
script with:

`python random_seq.py`

Oh, of course! You would need to specify the desired sequence length. Try again
with:

`python random_seq.py 20`

Ah, better! This script promises to be *really* useful, but you will need to
extend its functionality. To keep control over the development process, let's
put this code under version control with `git`.

To do so, while inside the folder with your script, run:

   `git init`
   
   This simple command will turn your folder into a `git` repository, for which
   `git` will, from now on, keep track of changes.
   
   Under the hood, `git` just created a `.git` folder inside your current
   directory. This is where all the bookkeeping of changes will happen.
   
Now run `git status` to see what's up with your brand new repo.
You should see output approximately like this:

```
On branch master

No commits yet

Untracked files:
  (use "git add <file>..." to include in what will be committed)
	random_seq.py

nothing added to commit but untracked files present (use "git add" to track)
```

Hmm, what is that supposed to tell you. First of all, a *commit* in `git` is
like a snapshot of a given repository at a given point in time, which you can
always go back to later. So *commits* are at the very heart of version control,
but the status message says that you don't have any yet. This is because the
`git init` command only sets up the repo, but doesn't yet save a snapshot of it.

The second part of the message tells you that `git` already knows about your
Python script, but doesn't track changes to it yet (that's what *untracked
file* means). At this point any snapshot of the repo would *not* include your
script, but conveniently enough `git` also tells you how to change this.
Follow the instructions and run:

`git add random_seq.py`

and after another `git status` you should see something like:

```
On branch master

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
	new file:   random_seq.py
```

Hmm, still no commits :( At least, the file is now tracked and there's "A
change to be committed".

-----

**The working directory, commits and the staging area**

You can put anything you like into a directory that's under `git` version
control. `git` will ignore everything you didn't explicitly tell it to track
changes for (it will only let you know that there are untracked items in the
status output).

Even changes in *tracked* files will not automatically make it into the next
commit (i.e. the next snapshot of the repository). You need to run `git add
your_file` to add these changes to the changes to be committed. Changes to be
committed are managed by git in what is called a *staging area*. For previously
*untracked* files (like our script) `git add` performs the dual action of
adding the file to the list of tracked files and of adding all of its content
(since its new) to the staging area.

-----

We're very close to creating our first commit now. All that's left to do is to
run:

`git commit`

If you do that, git will drop you into your system's default command-line text
editor and will wait for you to type and save a git commit *message*. Type a
brief one-line message on the first line (like *Add first version of script*),
save and exit from the text editor (saving and exiting will require some key
combinations that are different between different editors). If you typed
something and saved successfully, `git` should now have committed your changes.

-----

**git commit messages**

While working on your commit message you should have seen lots of additional
lines of text that were autogenerated by `git`. All these lines of text where
prefixed with `#` though, which marks them as comment lines that will be
excluded from the final commit message. These comments are `git`'s way to give
you a final overview of the changes it will commit. It can be worthwhile to
take a brief look, at least, at these comments. If you're discovering that you
are about to commit something that doesn't look right, just leave the text
editor without typing any non-comment text. Such an empty commit message will
abort the commit process.

Commit messages are meant to help others and your future self to understand
what changes between this commit and the last one are supposed to do. Writing
good and informative commit messages is an art in itself. A very good
introduction into this topic can be found
[here](https://chris.beams.io/posts/git-commit/).

-----

#### Version control in action

Now that we've taken a snapshot of our repository, we can start modifying our
script with confidence. If we mess anything up, `git` will always let us restore
the script to the state in a previous commit. So let's do some changes!

The initial code can be improved in *many* ways. One immediate thing we could
improve easily is the handling of the script's only error message as opposed to
reular output. For various reasons (beyond the scope of this introduction) it is
not a good idea to handle (i.e. to print) and error message just like regular
script output. This will make it unnecessarily hard, for example, to distinguish
successful runs of your script from failed ones in other code that might use
your script. A much better way to terminate a Python script on an error
condition is to use the `exit` function of the `sys` instead of `print`.

On line 10 of the script simply replace `print` with `sys.exit` to make your
script conform to standards, like so:

`    sys.exit('Need to know the length of the sequence to generate')`

Use any text editor you like for this purpose, then save your changes.

Now back on the command-line check what `git status` has to say about this change:

```
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   random_seq.py

no changes added to commit (use "git add" and/or "git commit -a")
```

So true and yet so boring! Don't worry though - `git` can do much more. Try
this:

`git diff`

-----

**Understanding git diff**

By default, the `git diff` command will show you all differences between the
current version of any tracked files on disk and the contents of the staging
area or, if the staging area is empty (like right now), of the last commit.

The new version of lines is prefixed with a `+`, old line contents are marked
with `-` instead.

If you want to see instead the differences between your staging area and the
last commit, *i.e.* what would be committed if you ran `git commit` right now,
run `git diff --staged`. Doing this now, will not show any output because you
haven't staged anything yet - remember you need `git add` for this.

-----

You can now run the script again to check that it's still behaving as intended.
If all looks good, you can then add the change to the staging area with
`git add random_seq.py` and confirm that things are ok with `git status`:

```
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	modified:   random_seq.py
```

Nice! Note that `git` even provides a usage hint in case you want to revert the staging.

Now this change seems almost too trivial to commit on its own (though in general
better create too many commits than to few and try to have every commit
introduce something you can describe in a single sentence). Maybe we can make
our script respect even more standards in the Python world while we're at it.

One such standard is that if a script contains reusable functionality that you
might want to gain access to from other python code, you should use the
`__name__ == '__main__'` trick.

-----

**The `__name__ == '__main__'` trick**

When Python executes code as a script, it simply executes all lines of the
script in order. Unfortunately, exactly the same is what happens when you
`import` the same code as a module as part of another Python program. While
that works fine for defining functions and setting module variables, the
`sys.argv` handling part of a script doesn't make any sense on `import`. You
would much rather want to gain access to the imported modules functions to call
them according to the logic of the importing code.

Python's solution for this dual use of code (as a script *and* an importable
module) is a special variable called `__name__`. Before Python starts executing
any code file as part of a module `import` it sets this special variable to the
name of the file. When Python executes that same file as a script, *i.e.* as the
main program, it sets that variable to the string `__main__`.

This means any Python code can check whether it's currently getting executed as
a script or as the result of an `import` by checking the content of `__name__`!

Normally this check takes the form of:

```
# do stuff useful as a module here, like
# other imports, setting variables, defining functions, etc.

if __name__ == '__main__':
    # ah, this is running as a script!
    # do things only useful in script context in this if block
    print('running as script!')
```

-----

Ok, so let's put an `if __name__ == '__main__':` conditional in front of line 9
of the current script and indent all following lines to become part of that
`if` block.

Save the changes and go back to the command-line and `git status`:

```
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	modified:   random_seq.py

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   random_seq.py
```

Funny to see the same file now mentioned twice - once in the staging area, once
in the tracked, but unstaged changes list ...

Investigating with `git diff` and `git diff --staged` should clarify what's
going on. While `git diff` will show only the addition of the `if` block,
`git diff --staged` will show our previous `sys.exit` change.

That's because *only* the older change is currently staged for committing (we
haven't run `git add` again after saving the latest changes so currently *only*
the `sys.exit` change would become part of the next commit.

Maybe that's exactly what you want, then you could run `git commit` now and
hold the `if` block thing back as an uncommitted change for now. Even before
committing anything, you could now decide that you don't trust this whole
`__name__ == '__main__'` magic and roll back that part of the code changes
separately from the `sys.exit` part (the `git status` message tells you how
you'd do that under `Changes not staged for commit:`).

If you want to commit both your changes together though, you should now first
verify that the latest version of the code is still running, then use
`git add random_seq.py` to update your staging area with the latest changes.
Then you can use `git commit` as before (a reasonable commit message might be:
`Conform to Python script standards`) to create your second snapshot of the
code.

At this point it's time to introduce a new `git` command. Run:

`git log`

and you should see output like this:

```
commit 64c2cd7c206ca9ae3ff9865e57a78b60055e0954 (HEAD -> master)
Author: Wolfgang Maier <maierw@informatik.uni-freiburg.de>
Date:   Wed Jul 21 17:40:17 2021 +0200

    Conform to Python script standards

commit 89ba3e18ce008b2fad2dead7f115996a580090b2
Author: Wolfgang Maier <maierw@informatik.uni-freiburg.de>
Date:   Wed Jul 21 16:45:18 2021 +0200

    Add first version of script
```

You could also run `git log -p` to display not only the commit messages, but
also the actual changes introduced by each commit.

Congratulations! You have created your first version-controlled piece of
software!
